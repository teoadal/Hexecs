# EntityWorld

Привет! Это движок, имплементирующий ECS. Тут ты можешь делать многое, к чему и так привык. 
При этом, ты можешь чуть больше, чем обычные ECS, так как помимо ECS в библиотеке есть встроенный CQRS и DI. 
CQRS в связке с ECS представляется мне максимально подходящей штукой для управления состоянием сущностей через системы.
DI необходим для того, чтобы всё это работало удобно.

## Создание мира

Так как всё в этом мире завязано на DI, им мы и будем пользоваться при создании объекта World.
```csharp
var provider = new ServiceCollection()
    .AddWorld()
    .BuildServiceProvider();
    
var world = provider.GetRequired<World>();
```
Этот код создаёт IServiceProvider и получает от него сконфигурированный объект World, который имеет набор полей для работы с созданным миром.

### Создание компонента

Компонент - это один из базовых кирпичиков ECS. 
Для того, чтобы системы могли наполнить сущность жизнью, сущность должна обладать признаками - компоненты и есть эти признаки.

```csharp
public struct FlyComponent {
    public bool CurrentSpeed;
    public bool MaxSpeed;
}
```
Компоненты должны быть `struct`, чтобы вся система могла их быстро и эффективно получать и использовать.
Например, обрабатывать в системах или обработчиках шины сообщений. Маркерного интерфейса для компонента не требуется. 

### Создание сущности

В этом мире есть две сущности - Actor'ы и Asset'ы. 
**Актёры** это динамичные изменяемые сущности, которые могут создаваться и удаляться, которым можно добавлять и у которых можно удалять компоненты.
**Ассеты** - это не изменяемые сущности, представляющие из себя настройки мира, но которые также имеют компоненты.
Единственное отличие - их нельзя создавать в процессе работы, так как они, по задумке, представляют из себя ресурсы, на основе которых будут создаваться актёры.

Создать актёра можно следующим образом:
```csharp
Actor actor = world.Actors.Create();
```
Конечно же, ему можно задать собственный идентификатор. 
Также, для целей экономии, можно создать актёра полностью и только после этого уведомить всех заинтересованных о его создании. А заинтересованных много, например, фильтры.
```csharp
Actor<Fly> actor = world.Actors
    .Build(yourActorId)
    .Add(new Fly { CurrentSpeed = 5, MaxSpeed = 7 })
    .End<Fly>();
```
В этом случае был создан т.н. "типизированный актёр" или актёр, в котором точно есть летающий компонент.
Эта щепотка типизации очень в случаях, когда вам хотелось бы знать заранее - действительно ли актёр содержит нужный компонент. Например, в шине сообщений.

Структура `Actor` и `Actor<T>` предоставляют удобную обёртку для взаимодействия с актёром. Актёр знает к какому `ActorContext` он принадлежит и просто проксирует методы к контексту, чтобы программисту было проще.

Более привычным типом entity для классических ECS будет являться содержимое поля `Actor.Id`, которое содержит в себе структуру `ActorId` - как раз тот самый идентификатор, который более привычен большинству программистов, сталкивающихся с ECS.

### Добавление компонентов

Созданный актёр может быть создан с использованием метода `world.Actors.Create()`. 
В этом случае он не будет обладать компонентом `Fly`. Добавим его с необходимыми значениями:
```csharp
actor.Add(new Fly { CurrentSpeed = 5, MaxSpeed = 7 });
```
То, что компонент теперь принадлежит актёр можно легко проверить с помощью метода:
```csharp
actor.Contains<Fly>();
```

Компонент `Fly` это, конечно, круто. Однако, мы бы хотели создать самолёт. Он действительно может летать, но ему не хватает двигателя. 
Хотя бы одного. Давай создадим его, но не через добавление уже настроенного компонента, а именно создадим:
```csharp
ref Engine engine = ref actor.Create<Engine>();
engine.CurrentPower = 80;
engine.MaxPower = 100;
```

Поздравляю, ты создал компонент и воспользовался возможностью передавать значимые типы по ссылке. 
Таким образом, если ты снова получишь двигатель в другом месте, значения его полей будут правильными:
```csharp
actor.Get<Engine>().CurrentPower;
```
Ещё один способ создания или добавления компонента предусмотрен для случаев, когда мы знаем только идентификатор актёра `ActorId`. 
Мы можем напрямую обратиться к конексту `ActorContext` и уже в нём манипулировать актёром.
```csharp
var actorContext = world.ActorContext;
var actorId = actor.Id;

actorContext.AddComponent(actorId, new Tank()); // добавляем настроенный компонент
actorContext.Create<Cabina>(actorId); // создаём "пустой" компонент 
```

### Удаление компонентов

Тут всё тоже предельно просто. Чтобы иммитировать наличие и отсутствие пилота самолёта, ты можешь создать компонет `Pilot` и обавить его к актёру-самолёту.
После того как пилот захотел спать, он покинет самолёт следующим способом:
```csharp
actor.Remove<Pilot>();
```
Если пилота там не было, метод вернёт `false` и ты соможешь обработать это вопиющее нарушение правил полётов. 
Если был, то метод вернёт `true`, а значит ты можешь быть уверен, что сможешь посадить в самолёт ещё одного пилота.
